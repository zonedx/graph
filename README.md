### 图的基本表示

                 邻接矩阵           邻接表(LinkedList)    邻接表(TreeSet)
    空间复杂度     O(V^2)            O(V+E)                  O(V+E)
    时间复杂度   建图：O(E)           O(E*V)                  O(ElogV)
            查看两点是否相邻：O(1)     O(degree(v))           O(logV)
            求一个点的相邻点：O(V)     O(degree(v))           O(degree(v))

图的深度优先遍历:   
    实际上和树的深度优先遍历实现思路是相同的，只是bst最多只有两个孩子，而图可能有其他V-1个顶点与之相连，
    递归调用时就需要遍历所有相邻的顶点。
    
   时间复杂度：
    **O(V+E)**

图的广度优先遍历：
    实际上和树的广度优先遍历也是相同的。广度优先遍历结果也是无权图的最短路径。
    时间复杂度：**O(V+E)**
    
DFS和BFS之间的联系：
    当DFS使用非递归算法时和BFS十分相像，逻辑几乎一样，区别在于BFS使用queue而DFS使用stack
    
图的建模 (floodfill)   
    **二维映射一维**（x,y）-> x*C+y
    **一维映射二维**   v  -> x = v/C  y = v%C
    
不要盲目的相信高级的算法，比如归并排序，快速排序时间复杂度都为O(nlogn) 但是是在n较大的时候才体现出来效果
有些时候插入排序，希尔排序都比上面两种高级的算法块，所以说适合的算法才是最好的
    
